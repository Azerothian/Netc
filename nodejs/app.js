// Generated by CoffeeScript 1.6.3
(function() {
  var Events, MemoryManager, Net, StringDecoder, TcpClient, TcpServer, server,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Net = require('net');

  Events = require('events');

  StringDecoder = require('string_decoder').StringDecoder;

  TcpServer = (function() {
    function TcpServer() {
      this.onClientData = __bind(this.onClientData, this);
      this.onCreateSocket = __bind(this.onCreateSocket, this);
      this.startListening = __bind(this.startListening, this);
      this.clients = [];
    }

    TcpServer.prototype.startListening = function(port) {
      this.server = Net.createServer(this.onCreateSocket);
      return this.server.listen(port);
    };

    TcpServer.prototype.onCreateSocket = function(socket) {
      var client,
        _this = this;
      socket.name = socket.remoteAddress + ":" + socket.remotePort;
      client = new TcpClient(socket, this);
      this.clients.push(client);
      client.on('data', this.onClientData);
      return socket.on('end', function() {
        return delete _this.clients[socket];
      });
    };

    TcpServer.prototype.onClientData = function(client, data) {
      var decoder, obj, result;
      decoder = new StringDecoder('utf8');
      result = decoder.write(data);
      obj = JSON.parse(result);
      return client.sendData(obj);
    };

    return TcpServer;

  })();

  TcpClient = (function(_super) {
    __extends(TcpClient, _super);

    function TcpClient(socket) {
      this.socket = socket;
      this.scanForPackets = __bind(this.scanForPackets, this);
      this.sendData = __bind(this.sendData, this);
      this.onData = __bind(this.onData, this);
      this.endOfFile = [0xff, 0xff, 0xff, 0xff];
      this.startOfFile = [0xfe, 0xff, 0xff, 0xff];
      this.endOfHeader = [0xfd, 0xff, 0xff, 0xff];
      this.memory = new MemoryManager();
      this.packets = [];
      this.socket.on('data', this.onData);
    }

    TcpClient.prototype.onData = function(data) {
      this.memory.write(data);
      return this.scanForPackets();
    };

    TcpClient.prototype.sendData = function(data) {
      var buf, bufPack, index, packetSize, str;
      str = JSON.stringify(data);
      buf = new Buffer(str, 'utf8');
      bufPack = new MemoryManager();
      packetSize = this.startOfFile.length + 4 + this.endOfHeader.length + buf.length + this.endOfFile.length;
      bufPack.setLength(packetSize);
      index = 0;
      bufPack.writeBytes(this.startOfFile, index);
      index += this.startOfFile.length;
      bufPack.buffer.writeInt32LE(buf.length, index);
      index += 4;
      bufPack.writeBytes(this.endOfHeader, index);
      index += this.endOfHeader.length;
      bufPack.writeBytes(buf, index);
      index += buf.length;
      bufPack.writeBytes(this.endOfFile, index);
      return this.socket.write(bufPack.buffer);
    };

    TcpClient.prototype.scanForPackets = function() {
      var data, i, index, packetSize, totalPacketSize, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.memory.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        index = i;
        if (index + this.startOfFile.length + 4 + this.endOfHeader.length > this.memory.length) {
          break;
        }
        if (!this.memory.compare(index, this.startOfFile)) {
          continue;
        }
        index += this.startOfFile.length;
        packetSize = this.memory.readInt32(index);
        index += 4;
        if (!this.memory.compare(index, this.endOfHeader)) {
          continue;
        }
        index += this.endOfHeader.length;
        if (this.memory.length < index + packetSize + this.endOfFile.Length) {
          break;
        }
        if (!this.memory.compare(index + packetSize, this.endOfFile)) {
          continue;
        }
        data = this.memory.slice(index, index + packetSize);
        totalPacketSize = this.startOfFile.length + 4 + this.endOfHeader.length + packetSize + this.endOfFile.length;
        this.memory.remove(0, i + totalPacketSize);
        this.emit('data', this, data);
        break;
      }
      return _results;
    };

    return TcpClient;

  })(Events.EventEmitter);

  MemoryManager = (function() {
    MemoryManager.prototype.length = 0;

    function MemoryManager() {
      this.readInt32 = __bind(this.readInt32, this);
      this.getBuffer = __bind(this.getBuffer, this);
      this.compare = __bind(this.compare, this);
      this.clear = __bind(this.clear, this);
      this.slice = __bind(this.slice, this);
      this.remove = __bind(this.remove, this);
      this.write = __bind(this.write, this);
      this.setLength = __bind(this.setLength, this);
      this.writeBytes = __bind(this.writeBytes, this);
    }

    MemoryManager.prototype.writeBytes = function(array, index) {
      var arrayIndex, bufferIndex, i, _i, _ref, _results;
      _results = [];
      for (i = _i = index, _ref = index + array.length; index <= _ref ? _i < _ref : _i > _ref; i = index <= _ref ? ++_i : --_i) {
        bufferIndex = i;
        arrayIndex = i - index;
        _results.push(this.buffer[bufferIndex] = array[arrayIndex]);
      }
      return _results;
    };

    MemoryManager.prototype.setLength = function(length) {
      this.buffer = new Buffer(length);
      return this.length = length;
    };

    MemoryManager.prototype.write = function(source) {
      if (this.buffer == null) {
        this.buffer = new Buffer(source.length);
        source.copy(this.buffer);
      } else {
        this.buffer.concat(source);
      }
      return this.length = this.buffer.length;
    };

    MemoryManager.prototype.remove = function(start, end) {
      var sectionSize;
      if (end == null) {
        end = this.buffer.length;
      }
      sectionSize = start - end;
      if (sectionSize > 0 && end < this.buffer.length) {
        this.newBuffer = new Buffer(this.buffer.length - sectionSize);
        if (start > 0) {
          this.buffer.copy(newBuffer, 0, 0, start);
        }
        if (end < this.buffer.length) {
          this.buffer.copy(newBuffer, end, this.buffer.length);
        }
        return this.buffer = newBuffer;
      } else if (start === 0 && end === this.buffer.length) {
        return this.buffer = null;
      }
    };

    MemoryManager.prototype.slice = function(start, end) {
      var newBuffer, newBufferSize;
      newBufferSize = end - start;
      newBuffer = new Buffer(end - start);
      this.buffer.copy(newBuffer, 0, start, end);
      return newBuffer;
    };

    MemoryManager.prototype.clear = function() {
      this.buffer = null;
      return this.length = 0;
    };

    MemoryManager.prototype.compare = function(index, array) {
      var arrayIndex, bufferIndex, i, _i, _ref;
      for (i = _i = index, _ref = index + array.length; index <= _ref ? _i < _ref : _i > _ref; i = index <= _ref ? ++_i : --_i) {
        bufferIndex = i;
        arrayIndex = i - index;
        if (this.buffer[bufferIndex] !== array[arrayIndex]) {
          return false;
        }
      }
      return true;
    };

    MemoryManager.prototype.getBuffer = function() {
      return this.buffer;
    };

    MemoryManager.prototype.readInt32 = function(index) {
      return this.buffer.readInt32LE(index);
    };

    return MemoryManager;

  })();

  server = new TcpServer();

  server.startListening(6112);

}).call(this);
